
#### 数据传输的历史

1. 远程过程调用（remote procedure call，RPC）发明于20世纪60年代。远程过程调用由客户端发起，向远程计算机发起请求以执行某些操作。接下来，远程计算机则向客户端发送响应。那个年代的计算机虽然与今天所使用的不可同日而语，但是信息传输过程却基本相同，即客户端请求，服务器响应。

2. 20世纪90年代末，微软提出了简单对象访问协议（SimpleObject Access Protocol，SOAP）。SOAP使用XML将消息编码并通过HTTP传输，集成了类型检测系统，并引入了面向资源的数据调用概念。SOAP所提供的结果具有可预测性，可惜的是由于其实现过于复杂而导致失败的概率也很高。

3. 表述性状态传递（REST）今天各位最熟悉的API范例就是表述性状态传递（Representational State Transfer，REST）。REST描述了一种面向资源的架构，用户可以通过执行GET、POST、PUT和DELETE等操作来浏览Web资源。它把资源网络看成虚拟状态机，并且用户执行的动作（GET、POST、PUT、DELETE）都是机器内的状态变化。

​	虽然从简单对象访问协议（SOAP）过渡到了表述性状态传递（REST），但是API的接口数量变多且维护的成本也变高了。一般来说接口的数量通常由业务场景来决定，为了尽量减少接口数量以优化请求，后端工程师们需要构建低粒度的数据接口，再根据业务场景进行组合，对外暴露业务接口。此外，接口的扩展成本也提升了。移动端不需要太多的字段，PC端则需要展示更多的数据，需求可谓南辕北辙。再者，单页面出于SEO的原因也需要对首屏进行性能优化，不仅需要进行服务端渲染（SSR），还要对接口进行合并。

------

#### GraphQL的起源

​	2012年，那时Facebook决定重新构建原生移动应用。彼时公司的RESTful服务器和SQL数据库性能不佳，工程师们意识到他们需要改进将数据发送到客户端应用的方式。团队决定从客户端角度重新考虑他们的数据。以此为契机，他们着手构建一种查询语言，它可以描述其所需数据模型的功能和需求，为公司的客户端/服务端提供便利。

​	2015年7月，该团队发布了最初的GraphQL规范以及基于JavaScript的实现库graphql.js。

​	2016年9月，在Facebook内部使用了许多年后，GraphQL脱离了“技术预览”阶段，这宣告GraphQL正式进入生产环境。如今，GraphQL在几乎所有的Facebook数据获取方面发挥着不可替代的作用，并被IBM、Intuit、Airbnb等公司广泛采用。

------

#### GraphQL的可用性

​	前文已经阐述了 GraphQL 的优点，但并不代表 GraphQL 优于 REST。这是两种不同的设计模式，互有长短。而哪种模式更适宜则是由具体的场景所决定的。就如同一家餐厅，有的客户喜欢单点，而有的客户喜欢套餐。

​	GraphQL 在以下场景下不太适宜：

 1. 较为单一的业务

    GraphQL 开发是以构建数据模型 Scheme 为中心的。如果业务场景功能单一，则直接使用原有的模式即可。例如用户相关的 API 处理新用户注册、填写短信验证码之类的事情，这些业务都是围绕着一个用户的具体某项或多项信息发生的，根本没有任何图的概念。若强行使用 GraphQL，非但得不到显著的好处，反而增加开发成本。

2. 表结构的存储数据

   GraphQL 数据是图状数据结构。对于部分 Nosql 数据可以直接连接和操作。但对于MySql、Oracle 表结构的数据则必须做优化，否则性能将因数据结构转换而添加额外开销。 Facebook 等一线大公司并未公开项目的后端结构。而自主研发对于国内众多互联网公司来说，前期人力投入与试错成本都是巨大的。

3. 嵌套层级深的数据

   GraphQL 尽管查询的数据是图状数据结构，但实际获得的数据视图是树状数据结构。每一个 GraphQL 查询或更新都有自己的根节点，然后所有的数据都是从根结点展开出去的。查询后获得的数据如果要在前端重新变回图的状态。这样一来前端就不能简单地缓存查询得到的数据，必须用对用的 GraphQL 存储库，然后通过顶点的 ID 把不同节点之间的某些边重新连接起来。

4. 需要明确请求状态的接口

   GraphQL 自带异常容错机制，错误信息包含在响应体中，响应状态码都是 200 。HTTP状态码自带的语义得不到充分利用。GraphQL 是前后端分离开发的间接产物，主要关注于数据操作，而 HTTP 网络请求的功能则覆盖面大得多。


